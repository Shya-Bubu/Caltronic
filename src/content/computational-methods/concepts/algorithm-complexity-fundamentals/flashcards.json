{
    "id": "algorithm-complexity-fundamentals-flashcards",
    "cards": [
        {
            "id": "fc-1",
            "front": "Big-O Notation Definition",
            "back": "f(n) = O(g(n)) if there exist constants c > 0 and n₀ such that:\n\nf(n) ≤ c·g(n) for all n ≥ n₀\n\nMeaning: f grows no faster than g for large n",
            "difficultyLevel": 1
        },
        {
            "id": "fc-2",
            "front": "Simplification Rules for Big-O",
            "back": "1. Drop constants: O(5n) = O(n)\n2. Drop lower-order terms: O(n² + n) = O(n²)\n3. Add sequential: O(n) + O(n²) = O(n²)\n4. Multiply nested: O(n) × O(n) = O(n²)",
            "difficultyLevel": 1
        },
        {
            "id": "fc-3",
            "front": "Common Complexity Classes (Fastest to Slowest)",
            "back": "O(1) - Constant\nO(log n) - Logarithmic\nO(n) - Linear\nO(n log n) - Linearithmic\nO(n²) - Quadratic\nO(n³) - Cubic\nO(2ⁿ) - Exponential",
            "difficultyLevel": 1
        },
        {
            "id": "fc-4",
            "front": "Dense Matrix-Vector Multiply Complexity",
            "back": "For n×n matrix:\n\nTime: O(n²)\nSpace: O(n²) for matrix, O(n) for vectors\n\nEach of n elements of result requires n multiplications",
            "difficultyLevel": 1
        },
        {
            "id": "fc-5",
            "front": "Dense LU Factorization Complexity",
            "back": "For n×n matrix:\n\nTime: O(n³), specifically ≈ (2/3)n³ operations\nSpace: O(n²)\n\nThis is why dense methods fail for large circuits!",
            "difficultyLevel": 1
        },
        {
            "id": "fc-6",
            "front": "Sparse Matrix-Vector Multiply Complexity",
            "back": "For matrix with nnz non-zeros:\n\nTime: O(nnz)\nSpace: O(nnz) for matrix\n\nFor circuits: nnz ≈ O(n), so O(n) time vs O(n²) dense",
            "difficultyLevel": 1
        },
        {
            "id": "fc-7",
            "front": "How to Analyze Loop Complexity",
            "back": "1. Identify loop bounds\n2. Count iterations of innermost loop\n3. Multiply by outer loop iterations\n4. Sum if loops are sequential\n\nExample: for i=1 to n, for j=1 to i\nTotal: 1+2+...+n = n(n+1)/2 = O(n²)",
            "difficultyLevel": 1
        },
        {
            "id": "fc-8",
            "front": "Scaling Formula",
            "back": "If algorithm is O(nᵏ):\n\nTime(2n) / Time(n) = 2ᵏ\n\nO(n): 2× problem = 2× time\nO(n²): 2× problem = 4× time\nO(n³): 2× problem = 8× time",
            "difficultyLevel": 1
        },
        {
            "id": "fc-9",
            "front": "Time vs Space Complexity",
            "back": "Time Complexity: Number of operations\nSpace Complexity: Memory usage\n\nBoth are functions of input size n\nBoth matter! Out of memory = infinite time",
            "difficultyLevel": 1
        },
        {
            "id": "fc-10",
            "front": "Why log base doesn't matter in Big-O",
            "back": "log_a(n) = log_b(n) / log_b(a)\n\nThe 1/log_b(a) is a constant, which Big-O ignores!\n\nSo O(log₂ n) = O(ln n) = O(log₁₀ n) = O(log n)",
            "difficultyLevel": 1
        },
        {
            "id": "fc-11",
            "front": "Polynomial vs Exponential",
            "back": "Polynomial: O(nᵏ) for any constant k\nExponential: O(cⁿ) for any constant c > 1\n\nKey fact: ANY polynomial grows slower than ANY exponential\n\nlim(n→∞) nᵏ/cⁿ = 0",
            "difficultyLevel": 1
        },
        {
            "id": "fc-12",
            "front": "Circuit Matrix Sparsity",
            "back": "Typical circuits: nnz ≈ 4n to 10n\n(Each node connects to ~4-10 elements)\n\nSparsity ≈ 99% or more for large circuits\n\nThis is why sparse methods are essential!",
            "difficultyLevel": 1
        }
    ]
}