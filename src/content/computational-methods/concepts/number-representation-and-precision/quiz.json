{
    "id": "number-representation-quiz",
    "questions": [
        {
            "id": "q1",
            "prompt": "Machine epsilon for double precision is approximately:",
            "options": [
                "2.22 × 10⁻⁷",
                "2.22 × 10⁻¹⁶",
                "1.0 × 10⁻¹⁵",
                "1.0 × 10⁻³⁰⁸"
            ],
            "correctAnswer": "2.22 × 10⁻¹⁶",
            "explanation": "Machine epsilon for 64-bit double precision is 2⁻⁵² ≈ 2.22 × 10⁻¹⁶. This represents the relative precision of floating-point arithmetic."
        },
        {
            "id": "q2",
            "prompt": "How many significant decimal digits does double precision provide?",
            "options": [
                "7",
                "10-12",
                "15-16",
                "30-32"
            ],
            "correctAnswer": "15-16",
            "explanation": "With 52 mantissa bits (plus implied 1), double precision provides log₁₀(2⁵³) ≈ 15.95 significant decimal digits."
        },
        {
            "id": "q3",
            "prompt": "Why does 0.1 + 0.2 ≠ 0.3 in floating-point?",
            "options": [
                "Python bug",
                "0.1 and 0.2 are repeating fractions in binary",
                "Integer overflow",
                "Division by zero"
            ],
            "correctAnswer": "0.1 and 0.2 are repeating fractions in binary",
            "explanation": "Just as 1/3 = 0.333... in decimal, the numbers 0.1 and 0.2 are infinite repeating fractions in binary. When rounded to 52 bits, the representations are inexact."
        },
        {
            "id": "q4",
            "prompt": "What is catastrophic cancellation?",
            "options": [
                "Overflow when multiplying large numbers",
                "Loss of precision when subtracting nearly equal numbers",
                "Division by a very small number",
                "Memory corruption"
            ],
            "correctAnswer": "Loss of precision when subtracting nearly equal numbers",
            "explanation": "When subtracting two nearly equal numbers, most significant digits cancel, leaving few reliable digits in the result. This can dramatically reduce precision."
        },
        {
            "id": "q5",
            "prompt": "IEEE 754 double precision uses how many bits for the exponent?",
            "options": [
                "8",
                "11",
                "23",
                "52"
            ],
            "correctAnswer": "11",
            "explanation": "Double precision (64-bit) uses: 1 bit sign + 11 bits exponent + 52 bits mantissa = 64 bits total."
        },
        {
            "id": "q6",
            "prompt": "Which comparison is safer for floating-point values?",
            "options": [
                "if x == 0.5:",
                "if x > 0.5:",
                "if abs(x - 0.5) < tolerance:",
                "if int(x) == 0:"
            ],
            "correctAnswer": "if abs(x - 0.5) < tolerance:",
            "explanation": "Due to rounding errors, exact equality rarely works for floats. Using a tolerance-based comparison (|x - target| < ε) is much more robust."
        },
        {
            "id": "q7",
            "prompt": "The gap between adjacent floating-point numbers near 10⁸ is approximately:",
            "options": [
                "10⁻¹⁶",
                "10⁻⁸",
                "10⁻²",
                "10²"
            ],
            "correctAnswer": "10⁻⁸",
            "explanation": "Gap ≈ ε × magnitude = 10⁻¹⁶ × 10⁸ = 10⁻⁸. Floating-point spacing is proportional to the number's magnitude."
        },
        {
            "id": "q8",
            "prompt": "What is a denormal (subnormal) number?",
            "options": [
                "A number larger than the maximum",
                "A number very close to zero with reduced precision",
                "A negative number",
                "An imaginary number"
            ],
            "correctAnswer": "A number very close to zero with reduced precision",
            "explanation": "Denormal numbers fill the gap between zero and the smallest normal number, allowing gradual underflow. They have fewer significant bits than normal numbers."
        },
        {
            "id": "q9",
            "prompt": "NaN (Not a Number) results from operations like:",
            "options": [
                "1/0",
                "1 + 1",
                "0/0 or ∞ - ∞",
                "sqrt(4)"
            ],
            "correctAnswer": "0/0 or ∞ - ∞",
            "explanation": "NaN represents undefined operations like 0/0, ∞/∞, ∞ - ∞, or sqrt(-1). Note: 1/0 gives ±∞, not NaN."
        },
        {
            "id": "q10",
            "prompt": "To avoid catastrophic cancellation in x² - y², use:",
            "options": [
                "x² - y²",
                "(x + y)(x - y)",
                "sqrt(x² - y²)",
                "x - y"
            ],
            "correctAnswer": "(x + y)(x - y)",
            "explanation": "The factored form (x+y)(x-y) is mathematically equivalent but avoids subtracting nearly equal numbers (x² and y²), preserving more precision."
        }
    ]
}