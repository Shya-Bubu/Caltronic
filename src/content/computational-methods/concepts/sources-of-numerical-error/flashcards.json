{
    "id": "sources-of-numerical-error-flashcards",
    "cards": [
        {
            "id": "f1",
            "front": "Three main sources of numerical error",
            "back": "1. Truncation error (finite approximations)\n2. Round-off error (floating-point precision)\n3. Propagation error (error amplification)",
            "difficultyLevel": 2
        },
        {
            "id": "f2",
            "front": "Truncation error",
            "back": "Error from approximating infinite or continuous processes with finite ones.\n\nExample: Using only 5 terms of a Taylor series.",
            "difficultyLevel": 2
        },
        {
            "id": "f3",
            "front": "Relative vs absolute error",
            "back": "Absolute: |x_true - x_approx|\nRelative: |x_true - x_approx| / |x_true|\n\nRelative error is usually more meaningful.",
            "difficultyLevel": 2
        },
        {
            "id": "f4",
            "front": "Condition number κ",
            "back": "κ = |x·f'(x)/f(x)|\n\nMeasures sensitivity of output to input.\nκ ≈ 1–10: well-conditioned\nκ >> 1: ill-conditioned",
            "difficultyLevel": 3
        },
        {
            "id": "f5",
            "front": "Forward difference error order",
            "back": "O(h) — First order\n\nError: ~ (h/2)f''(x)",
            "difficultyLevel": 2
        },
        {
            "id": "f6",
            "front": "Central difference error order",
            "back": "O(h²) — Second order\n\nError: ~ (h²/6)f'''(x)\n\nTwice as accurate as forward difference.",
            "difficultyLevel": 2
        },
        {
            "id": "f7",
            "front": "Why does error eventually INCREASE for very small h?",
            "back": "Round-off error dominates!\n\nFor tiny h, f(x+h) ≈ f(x), and their difference loses precision (catastrophic cancellation).",
            "difficultyLevel": 3
        },
        {
            "id": "f8",
            "front": "Optimal step size formula",
            "back": "h_opt ~ ε^(1/(p+1))\n\nFor central diff (p=2): h_opt ~ 10⁻⁵\nFor forward diff (p=1): h_opt ~ 10⁻⁸",
            "difficultyLevel": 3
        },
        {
            "id": "f9",
            "front": "Backward stability",
            "back": "An algorithm is backward stable if the computed result is exact for a slightly perturbed input.\n\nForward error ≤ κ × Backward error",
            "difficultyLevel": 3
        },
        {
            "id": "f10",
            "front": "Why is computing e^(−20) via Taylor series bad?",
            "back": "Catastrophic cancellation!\n\nLarge alternating terms (+200, -1333, +2666...) cancel, losing precision.\n\nBetter: Compute 1/e^20 instead.",
            "difficultyLevel": 3
        }
    ]
}